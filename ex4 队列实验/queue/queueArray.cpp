#include "queueArray.h"
#include <iostream>
using namespace std;

//*********************************************************
//函数功能：初始化队列
//输入参数：队列指针
//输出参数：队列指针
//返回值： 	无
//*********************************************************
void InitialQueue( seqQueue &Q )
{
    Q.Front = 0;    //空队列，front和rear都指向第一个位置
    Q.Rear = 0;
}

//*********************************************************
//函数功能：判断队列是否为空
//输入参数：队列的引用
//输出参数：无
//返回值： 	true or false
//*********************************************************
bool IsQueueEmpty( seqQueue &Q )
{
    return Q.Front == Q.Rear;  //相等返回真，否则返回假
}

//*********************************************************
//函数功能：判断队列是否满
//输入参数：队列的引用
//输出参数：无
//返回值： 	true or false
//*********************************************************
bool IsQueueFull( seqQueue &Q )
{
    //判断逻辑环中rear的前一个是不是front，即队满
    return Q.Front == (Q.Rear + 1) % MAXLEN;
}

//*********************************************************
//函数功能：取队头元素
//输入参数：队列的引用，x的引用
//输出参数：x
//返回值： 	成功返回0，失败返回1
//*********************************************************
int GetQueueFront( seqQueue &Q, ElementType &x )
{
    if ( IsQueueEmpty(Q) ) //队空，返回1，
    {
        return 1;
    }
    else       //队不空，取逻辑环中front后面那个元素给x
    {
        x = Q.data[(Q.Front + 1) % MAXLEN];
    }
    return 0;  //成功，返回0
}

//*********************************************************
//函数功能：入队一个元素
//输入参数：队列的引用，待入队元素x
//输出参数：无
//返回值： 	成功返回0，失败返回1
//*********************************************************
int EnQueue( Queue Q, ElementType &x )
{
    if ( IsQueueFull (*Q) ) //队满，返回1
    {
        return 1;
    }
    else                //队还有空间，入队
    {
        Q->Rear = (Q->Rear + 1) % MAXLEN; //先更新rear指针
        Q->data[Q->Rear] = x;                        //再入队
    }
    return 0;
}

//*********************************************************
//函数功能：出队
//输入参数：队列的引用，
//输出参数：无
//返回值： 	成功返回0，失败返回1
//*********************************************************
int DeQueue( Queue Q )
{
    if ( IsQueueEmpty( *Q ) ) //如果队空,返回1
    {
        return 1;
    }
    else                                    //队不空，后移front
    {
        Q->Front = (Q->Front + 1) % MAXLEN;
    }
    return 0;
}

//*********************************************************
//函数功能：遍历队中元素
//输入参数：队列的引用
//输出参数：
//返回值： 	成功返回0，失败返回1
//*********************************************************
int TravelQueue( seqQueue &Q )
{
    if ( IsQueueEmpty( Q ) ) //空队列，返回1
    {
        return 1;
    }
    else
    {
        cout << "当前队列元素为：\n";
        //让i再逻辑环上从front前面那个位置开始走
        for ( int i = (Q.Front + 1) % MAXLEN ; i != (Q.Rear + 1) % MAXLEN; i = (i + 1 ) % MAXLEN )
        {
            cout << Q.data[i] << "  ";
        }
        cout << endl;
    }
    return 0;
}

//*********************************************************
//函数功能：计数队中元素个数
//输入参数：队列的引用
//输出参数：无
//返回值： 	 队列元素个数
//*********************************************************
int CoutElement( seqQueue &Q )
{
    int total = 0, i;       //for循环遍历逻辑环，并计数
    for ( i = (Q.Front + 1) % MAXLEN ; i != (Q.Rear + 1) % MAXLEN ; i = (i + 1) % MAXLEN )
    {
        total++;
    }
    return total;
}
